{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AsFem This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem . For efficient computation and simulation, the package is written in C++ and relies heavily on the PETSc library. It is primarily developed for solid mechanics and phase-field modeling. spinodal-decomposition double-notch failure","title":"Home"},{"location":"#welcome-to-asfem","text":"This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem . For efficient computation and simulation, the package is written in C++ and relies heavily on the PETSc library. It is primarily developed for solid mechanics and phase-field modeling. spinodal-decomposition double-notch failure","title":"Welcome to AsFem"},{"location":"about/","text":"What is it? This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem . What can it do ? [x] Solid Mechanics [x] CahnHilliard diffusion [x] Phase-field fracture model [x] Linear elastic materials How to use it ? The documentation is under construction at present. If you have any questions, just email me: Yang or for Chinese users, we can also discuss more about it in the QQ group:: 879908352","title":"About"},{"location":"about/#what-is-it","text":"This is A S imple F inite E lement M ethod program for the phase-field modeling and multiphysics simulation, which is short for AsFem .","title":"What is it?"},{"location":"about/#what-can-it-do","text":"[x] Solid Mechanics [x] CahnHilliard diffusion [x] Phase-field fracture model [x] Linear elastic materials","title":"What can it do ?"},{"location":"about/#how-to-use-it","text":"The documentation is under construction at present. If you have any questions, just email me: Yang or for Chinese users, we can also discuss more about it in the QQ group:: 879908352","title":"How to use it ?"},{"location":"install/","text":"Basic components Before we begin the installation, some components are needed, for example: gcc cmake git Install gcc You can use the steps below to install a modern GCC compiler if you don't already have one. Otherwise, go straight to the MPI setup . To begin, you should download and unzip the gcc source code: curl -L -O http://mirrors.concertpass.com/gcc/releases/gcc-9.3.0/gcc-9.3.0.tar.gz tar -xf gcc-9.3.0.tar.gz or directly go to the official website gcc . Next, we'll need to get the GCC pre-request: cd gcc-9.3.0 ./contrib/download_prerequisites we can then config, build and install GCC: ./configure --prefix=your-gcc-install-path \\ --disable-multilib \\ --enable-languages=c,c++,fortran,jit \\ --enable-checking=release \\ --enable-host-shared \\ --with-pic make -j4 make install Following the installation, we must configure our bash environment to use our modern GCC: export gcc=your-gcc-instal-path export PATH=$gcc/bin:$PATH export LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/9.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/9.3.0:$LD_LIBRARY_PATH you can either paste the above settings to your ~/.bashrc file or put it into a new file, i.e. ~/.asfem-profile . Install mpi The MPI compiler is required to use the PETSc package for parallelization. Please skip this stage if your machine already has the MPI compiler installed . curl -L -O https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.0.tar.gz Alternatively, you can get the source code from openmpi . Then you can config, build and install your openmpi: tar -xf openmpi-4.1.0.tar.gz cd openmpi-4.1.0 ./configure --prefix=*your-path-to-opemmpi* make -j8 make install After that, you should put the related settings in your bash environment as follows: export mpi=your-path-to-openmpi export PATH=$PATH:$mpi/bin export CC=mpicc export CXX=mpicxx export FC=mpif90 export F90=mpif90 export OMP_NUM_THREADS=1 export C_INCLUDE_PATH=$mpi/include:$C_INCLUDE_PATH export CPLUS_INCLUDE_PATH=$mpi/include:$CPLUS_INCLUDE_PATH export FPATH=$mpi/include:$FPATH export MANPATH=$mpi/share/man:$MANPATH export LD_LIBRARY_PATH=$mpi/lib:$LD_LIBRARY_PATH Install PETSc Before we begin, make sure your GCC and MPI compilers are up to date : source ~/.asfem-profile gcc --version mpicxx --version The PETSc package can be downloaded via: curl -L -O https://ftp.mcs.anl.gov/pub/petsc/release-snapshots/petsc-lite-3.14.3.tar.gz or you can download it from the PETSc website . For the configuration, one can use: ./configure \\ --prefix=your-PETSc-install-path \\ --with-debugging=0 \\ --with-ssl=0 \\ --with-pic=1 \\ --with-openmp=1 \\ --with-mpi-dir=your-MPI-install-path \\ --with-shared-libraries=1 \\ --with-cxx-dialect=C++14 \\ --with-fortran-bindings=1 \\ --with-sowing=0 \\ --download-hypre=1 \\ --download-fblaslapack=1 \\ --download-ptscotch=1 \\ --download-metis=1 \\ --download-parmetis=1 \\ --download-superlu_dist=1 \\ --download-scalapack=1 \\ --download-mumps=1 \\ --download-slepc=1 \\ --download-fftw=1 \\ --download-hwloc=1 \\ COPTFLAGS='-fPIC -fopenmp -O3 ' \\ CXXOPTFLAGS='-fPIC -fopenmp -O3 ' \\ FOPTFLAGS='-fPIC -fopenmp -O3 ' \\ PETSC_DIR=`pwd` other external packages can be installed via -download-XXX=1 . Then, by running the make xxxxx -j8 and make xxxx install command, one can finish the installation. Here xxx represents the command line which is shown by PETSc in your terminal! Install AsFem Download AsFem: git clone https://github.com/yangbai90/AsFem.git if you want the have a try for the devel version(unstable), one can use: git clone -b devel https://github.com/yangbai90/AsFem.git then we can make asfem via: make -j4 the executable file asfem can be found in the AsFem/bin folder.","title":"Installation"},{"location":"install/#basic-components","text":"Before we begin the installation, some components are needed, for example: gcc cmake git","title":"Basic components"},{"location":"install/#install-gcc","text":"You can use the steps below to install a modern GCC compiler if you don't already have one. Otherwise, go straight to the MPI setup . To begin, you should download and unzip the gcc source code: curl -L -O http://mirrors.concertpass.com/gcc/releases/gcc-9.3.0/gcc-9.3.0.tar.gz tar -xf gcc-9.3.0.tar.gz or directly go to the official website gcc . Next, we'll need to get the GCC pre-request: cd gcc-9.3.0 ./contrib/download_prerequisites we can then config, build and install GCC: ./configure --prefix=your-gcc-install-path \\ --disable-multilib \\ --enable-languages=c,c++,fortran,jit \\ --enable-checking=release \\ --enable-host-shared \\ --with-pic make -j4 make install Following the installation, we must configure our bash environment to use our modern GCC: export gcc=your-gcc-instal-path export PATH=$gcc/bin:$PATH export LD_LIBRARY_PATH=$gcc/lib64:$gcc/lib:$gcc/lib/gcc/x86_64-pc-linux-gnu/9.3.0:$gcc/libexec/gcc/x86_64-pc-linux-gnu/9.3.0:$LD_LIBRARY_PATH you can either paste the above settings to your ~/.bashrc file or put it into a new file, i.e. ~/.asfem-profile .","title":"Install gcc"},{"location":"install/#install-mpi","text":"The MPI compiler is required to use the PETSc package for parallelization. Please skip this stage if your machine already has the MPI compiler installed . curl -L -O https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.0.tar.gz Alternatively, you can get the source code from openmpi . Then you can config, build and install your openmpi: tar -xf openmpi-4.1.0.tar.gz cd openmpi-4.1.0 ./configure --prefix=*your-path-to-opemmpi* make -j8 make install After that, you should put the related settings in your bash environment as follows: export mpi=your-path-to-openmpi export PATH=$PATH:$mpi/bin export CC=mpicc export CXX=mpicxx export FC=mpif90 export F90=mpif90 export OMP_NUM_THREADS=1 export C_INCLUDE_PATH=$mpi/include:$C_INCLUDE_PATH export CPLUS_INCLUDE_PATH=$mpi/include:$CPLUS_INCLUDE_PATH export FPATH=$mpi/include:$FPATH export MANPATH=$mpi/share/man:$MANPATH export LD_LIBRARY_PATH=$mpi/lib:$LD_LIBRARY_PATH","title":"Install mpi"},{"location":"install/#install-petsc","text":"Before we begin, make sure your GCC and MPI compilers are up to date : source ~/.asfem-profile gcc --version mpicxx --version The PETSc package can be downloaded via: curl -L -O https://ftp.mcs.anl.gov/pub/petsc/release-snapshots/petsc-lite-3.14.3.tar.gz or you can download it from the PETSc website . For the configuration, one can use: ./configure \\ --prefix=your-PETSc-install-path \\ --with-debugging=0 \\ --with-ssl=0 \\ --with-pic=1 \\ --with-openmp=1 \\ --with-mpi-dir=your-MPI-install-path \\ --with-shared-libraries=1 \\ --with-cxx-dialect=C++14 \\ --with-fortran-bindings=1 \\ --with-sowing=0 \\ --download-hypre=1 \\ --download-fblaslapack=1 \\ --download-ptscotch=1 \\ --download-metis=1 \\ --download-parmetis=1 \\ --download-superlu_dist=1 \\ --download-scalapack=1 \\ --download-mumps=1 \\ --download-slepc=1 \\ --download-fftw=1 \\ --download-hwloc=1 \\ COPTFLAGS='-fPIC -fopenmp -O3 ' \\ CXXOPTFLAGS='-fPIC -fopenmp -O3 ' \\ FOPTFLAGS='-fPIC -fopenmp -O3 ' \\ PETSC_DIR=`pwd` other external packages can be installed via -download-XXX=1 . Then, by running the make xxxxx -j8 and make xxxx install command, one can finish the installation. Here xxx represents the command line which is shown by PETSc in your terminal!","title":"Install PETSc"},{"location":"install/#install-asfem","text":"Download AsFem: git clone https://github.com/yangbai90/AsFem.git if you want the have a try for the devel version(unstable), one can use: git clone -b devel https://github.com/yangbai90/AsFem.git then we can make asfem via: make -j4 the executable file asfem can be found in the AsFem/bin folder.","title":"Install AsFem"},{"location":"release/","text":"All the release can be download from here AsFem-Release \ud83c\udf1f Version v0.5 is released! \ud83d\udca5 Breaking Changes Name-based material properties accessing Further simplify the user element coding, nodal loop is required anymore Citation is available in Zenodo \u2b50 Features Material properties projection Postprocesses for elemental and side DoFs/Materials integral \ud83d\udc1e Bug Fixes Fix setting errors in Gmsh2IO and Gmsh4IO \ud83d\udee0 Improvements Error detector for the boundary condition system","title":"Release"},{"location":"release/#version-v05-is-released","text":"","title":"\ud83c\udf1f Version v0.5 is released!"},{"location":"release/#breaking-changes","text":"Name-based material properties accessing Further simplify the user element coding, nodal loop is required anymore Citation is available in Zenodo","title":"\ud83d\udca5 Breaking Changes"},{"location":"release/#features","text":"Material properties projection Postprocesses for elemental and side DoFs/Materials integral","title":"\u2b50 Features"},{"location":"release/#bug-fixes","text":"Fix setting errors in Gmsh2IO and Gmsh4IO","title":"\ud83d\udc1e Bug Fixes"},{"location":"release/#improvements","text":"Error detector for the boundary condition system","title":"\ud83d\udee0 Improvements"},{"location":"Document/block-bcs/","text":"[bcs] block The block [bcs] is used to apply the different types of boundary conditions, i.e. Dirichlet boundary condition, Neumann boundary condition, Robin boundary condition, as well as User-Defined-BC ( UBC ). This block's layout looks as follows: [bcs] [mybc1] type=dirichlet dof=dof1 boundary=left right ... value=bcvalue [end] [end] options The type = option specifies the name of the boundary condition type one wants to use. dof= specifies which DoF we want to use. It should be noted that, only one DoF can be accepted, instead of multiple DoFs used in other blocks like [elmts] . boundary= specifies the name of the boundary, which we want to apply the related boundary condition. The name of the boundary should be defined in your mesh file. For the built-in mesh, we use left and right for the point/line/surface at xmin and xmax . Similarly, bottom and top are used for the line/surface at ymin and ymax . Then back and front are used for the surface at zmin and zmax . value= specifies the boundary value we want to use. It should be a single value, instead of several numbers. If one wants to apply the time dependent boundary condition, then he can use value=t*2.0 . Thus the boundary value will change overtime. supported boundary condition type The full list of the available boundary condition type is: type=dirichlet type=neumann","title":"bcs block"},{"location":"Document/block-bcs/#bcs-block","text":"The block [bcs] is used to apply the different types of boundary conditions, i.e. Dirichlet boundary condition, Neumann boundary condition, Robin boundary condition, as well as User-Defined-BC ( UBC ). This block's layout looks as follows: [bcs] [mybc1] type=dirichlet dof=dof1 boundary=left right ... value=bcvalue [end] [end]","title":"[bcs] block"},{"location":"Document/block-bcs/#options","text":"The type = option specifies the name of the boundary condition type one wants to use. dof= specifies which DoF we want to use. It should be noted that, only one DoF can be accepted, instead of multiple DoFs used in other blocks like [elmts] . boundary= specifies the name of the boundary, which we want to apply the related boundary condition. The name of the boundary should be defined in your mesh file. For the built-in mesh, we use left and right for the point/line/surface at xmin and xmax . Similarly, bottom and top are used for the line/surface at ymin and ymax . Then back and front are used for the surface at zmin and zmax . value= specifies the boundary value we want to use. It should be a single value, instead of several numbers. If one wants to apply the time dependent boundary condition, then he can use value=t*2.0 . Thus the boundary value will change overtime.","title":"options"},{"location":"Document/block-bcs/#supported-boundary-condition-type","text":"The full list of the available boundary condition type is: type=dirichlet type=neumann","title":"supported boundary condition type"},{"location":"Document/block-dofs/","text":"[dofs] block The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end] [dofs] block option The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else.","title":"dofs block"},{"location":"Document/block-dofs/#dofs-block","text":"The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end]","title":"[dofs] block"},{"location":"Document/block-dofs/#dofs-block-option","text":"The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else.","title":"[dofs] block option"},{"location":"Document/block-elmts/","text":"[elmts] block The block [elmts] is used to describe the model that we plan to use according to your particular problem. This block's layout looks as follows: [elmts] [subelmts1] type=elment-type2 dofs=dof1 dof2 mate=mate-name1 domain=geometry-domain-name1 [end] [subelmts2] type=elment-type2 dofs=dof1 dof2 mate=mate-name2 domain=geometry-domain-name2 [end] ... [end] options The type = option specifies the name of the element type (or the physical model) one wants to use. dofs= specifies which DoFs we want to use, it should be noted that one of the names in your [dofs] block must be the name we used here. mate= gives the material name, which should be the block name in your material block, not the material type name!!! This option can be ignored, then your element will not call any material calculation. domain= determines which domain will be applied to the current element. Users don't usually need this option, then all of your mesh domains will be used by default. supported element type The full list of the available element type is: type=poisson type=mechanics type=diffusion type=cahnhilliard","title":"elmts block"},{"location":"Document/block-elmts/#elmts-block","text":"The block [elmts] is used to describe the model that we plan to use according to your particular problem. This block's layout looks as follows: [elmts] [subelmts1] type=elment-type2 dofs=dof1 dof2 mate=mate-name1 domain=geometry-domain-name1 [end] [subelmts2] type=elment-type2 dofs=dof1 dof2 mate=mate-name2 domain=geometry-domain-name2 [end] ... [end]","title":"[elmts] block"},{"location":"Document/block-elmts/#options","text":"The type = option specifies the name of the element type (or the physical model) one wants to use. dofs= specifies which DoFs we want to use, it should be noted that one of the names in your [dofs] block must be the name we used here. mate= gives the material name, which should be the block name in your material block, not the material type name!!! This option can be ignored, then your element will not call any material calculation. domain= determines which domain will be applied to the current element. Users don't usually need this option, then all of your mesh domains will be used by default.","title":"options"},{"location":"Document/block-elmts/#supported-element-type","text":"The full list of the available element type is: type=poisson type=mechanics type=diffusion type=cahnhilliard","title":"supported element type"},{"location":"Document/block-ics/","text":"[ics] block The block [ics] is used to apply the initial condition for the DoFs. This block's layout looks as follows: [ics] [ic1] type=const dof=dof1 domain=domain-name params=val1 val2 ... [end] ... [end] options The type = option specifies the name of the initial condition type one wants to use. dof= specifies the name of the DoF. domain= indicates the domain name where the initial condition will be applied. params= gives the parameters which will be used in the initial condition calculation. supported initial condition type The full list of the available initial condition typ is: type=const type=random type=circle type=sphere type=rectangle type=cubic","title":"ics block"},{"location":"Document/block-ics/#ics-block","text":"The block [ics] is used to apply the initial condition for the DoFs. This block's layout looks as follows: [ics] [ic1] type=const dof=dof1 domain=domain-name params=val1 val2 ... [end] ... [end]","title":"[ics] block"},{"location":"Document/block-ics/#options","text":"The type = option specifies the name of the initial condition type one wants to use. dof= specifies the name of the DoF. domain= indicates the domain name where the initial condition will be applied. params= gives the parameters which will be used in the initial condition calculation.","title":"options"},{"location":"Document/block-ics/#supported-initial-condition-type","text":"The full list of the available initial condition typ is: type=const type=random type=circle type=sphere type=rectangle type=cubic","title":"supported initial condition type"},{"location":"Document/block-mates/","text":"[mates] block The block [mates] is used to calculate the material properties we plan to use according to our model, therefore, the material properties will be used by the [elmts] block. This block's layout looks as follows: [mates] [mymate1] type=linearelastic params=210.0 0.3 [end] [mymate2] type=linearelastic params=410.0 0.2 [end] ... [end] It should be noted that, the name of the block mymate1 should be the same as the one you give in [elmts] subblock(the mate=mymate1 option). options The type = option specifies the name of the element type (or the physical model) one wants to use. params= specifies the parameters we want to use in the material property calculation. supported material type The full list of the available element type is: type=constpoisson type=linearelastic type=cahnhilliard","title":"mate block"},{"location":"Document/block-mates/#mates-block","text":"The block [mates] is used to calculate the material properties we plan to use according to our model, therefore, the material properties will be used by the [elmts] block. This block's layout looks as follows: [mates] [mymate1] type=linearelastic params=210.0 0.3 [end] [mymate2] type=linearelastic params=410.0 0.2 [end] ... [end] It should be noted that, the name of the block mymate1 should be the same as the one you give in [elmts] subblock(the mate=mymate1 option).","title":"[mates] block"},{"location":"Document/block-mates/#options","text":"The type = option specifies the name of the element type (or the physical model) one wants to use. params= specifies the parameters we want to use in the material property calculation.","title":"options"},{"location":"Document/block-mates/#supported-material-type","text":"The full list of the available element type is: type=constpoisson type=linearelastic type=cahnhilliard","title":"supported material type"},{"location":"Document/block-mesh/","text":"[mesh] block The format of the block is: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end] [mesh] block options type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu .","title":"mesh block"},{"location":"Document/block-mesh/#mesh-block","text":"The format of the block is: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end]","title":"[mesh] block"},{"location":"Document/block-mesh/#mesh-block-options","text":"type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu .","title":"[mesh] block options"},{"location":"Document/block-nonlinearsolver/","text":"[nonlinearsolver] block The block [nonlinearsolver] is used for the newton-raphson nonlinear iteration. This block's layout looks as follows: [nonlinearsolver] type=nr maxiters=25 r_rel_tol=1.0e-8 r_abs_tol=1.0e-7 stol=1.0e-16 solver=superlu [end] options The type = option specifies the name of the nonlinear solver method one wants to use. maxiters= specifies maximum nonlinear iterations. r_rel_tol and r_abs_tol represent the relative and absolute errors of the residual( \\(||R||\\) ). stol= determines tolerance of the displacement error, namely \\(||\\Delta U||\\) . solver= indicates the name of linear solver, it could be: ksp , mumps , and superlu . supported nonlinear solver method The full list of the available nonlinear solver method is: type=nr // for newton-raphson with line search, the default one type=newtonls // same as the first one type=newtontr // NR with trust region method type=bfgs // BFGS method type=broyden // Broyden method","title":"nonlinear solver block"},{"location":"Document/block-nonlinearsolver/#nonlinearsolver-block","text":"The block [nonlinearsolver] is used for the newton-raphson nonlinear iteration. This block's layout looks as follows: [nonlinearsolver] type=nr maxiters=25 r_rel_tol=1.0e-8 r_abs_tol=1.0e-7 stol=1.0e-16 solver=superlu [end]","title":"[nonlinearsolver] block"},{"location":"Document/block-nonlinearsolver/#options","text":"The type = option specifies the name of the nonlinear solver method one wants to use. maxiters= specifies maximum nonlinear iterations. r_rel_tol and r_abs_tol represent the relative and absolute errors of the residual( \\(||R||\\) ). stol= determines tolerance of the displacement error, namely \\(||\\Delta U||\\) . solver= indicates the name of linear solver, it could be: ksp , mumps , and superlu .","title":"options"},{"location":"Document/block-nonlinearsolver/#supported-nonlinear-solver-method","text":"The full list of the available nonlinear solver method is: type=nr // for newton-raphson with line search, the default one type=newtonls // same as the first one type=newtontr // NR with trust region method type=bfgs // BFGS method type=broyden // Broyden method","title":"supported nonlinear solver method"},{"location":"Document/block-qpoint/","text":"[qpoint] block The block [qpoint] is used for the gauss point integration. This block's layout looks as follows: [qpoint] type=gauss order=3 [end] options The type = option specifies the type name of the gauss point integration. order= specifies gauss integration order(it's not the number of gauss points, instead, it's the order !) supported gauss integration method The full list of the available gauss integration is: type=gauss type=gausslobatto","title":"qpoint block"},{"location":"Document/block-qpoint/#qpoint-block","text":"The block [qpoint] is used for the gauss point integration. This block's layout looks as follows: [qpoint] type=gauss order=3 [end]","title":"[qpoint] block"},{"location":"Document/block-qpoint/#options","text":"The type = option specifies the type name of the gauss point integration. order= specifies gauss integration order(it's not the number of gauss points, instead, it's the order !)","title":"options"},{"location":"Document/block-qpoint/#supported-gauss-integration-method","text":"The full list of the available gauss integration is: type=gauss type=gausslobatto","title":"supported gauss integration method"},{"location":"Document/block-timestepping/","text":"[timestepping] block The block [timestepping] is used for the transient analysis. This block's layout looks as follows: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 dtmin=1.0e-12 dtmax=1.0e1 [end] options The type = option specifies the name of the time integration method one wants to use. dt= specifies initial \\(\\Delta_{t}\\) . time= defines the final time. adaptive=true enables the adaptive time stepping. It's disabled by default. optiters= determines the critical nonlinear iterations for increasing or decreasing the \\(\\Delta_{t}\\) . growthfactor= and cutfactor= represent the growth factor and cut back factor for adaptive time stepping, respectively. dtmin and dtmax determine the minimum and maximum value of \\(\\Delta_{t}\\) . supported time stepping method The full list of the available time stepping method is: type=be type=cn","title":"timestepping block"},{"location":"Document/block-timestepping/#timestepping-block","text":"The block [timestepping] is used for the transient analysis. This block's layout looks as follows: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 dtmin=1.0e-12 dtmax=1.0e1 [end]","title":"[timestepping] block"},{"location":"Document/block-timestepping/#options","text":"The type = option specifies the name of the time integration method one wants to use. dt= specifies initial \\(\\Delta_{t}\\) . time= defines the final time. adaptive=true enables the adaptive time stepping. It's disabled by default. optiters= determines the critical nonlinear iterations for increasing or decreasing the \\(\\Delta_{t}\\) . growthfactor= and cutfactor= represent the growth factor and cut back factor for adaptive time stepping, respectively. dtmin and dtmax determine the minimum and maximum value of \\(\\Delta_{t}\\) .","title":"options"},{"location":"Document/block-timestepping/#supported-time-stepping-method","text":"The full list of the available time stepping method is: type=be type=cn","title":"supported time stepping method"},{"location":"Tutorial/step-0/","text":"Write a simple input file: In your input file, the layout of the block should look like: [block_name] type=... option1=... option2=... [end] here, to set the properties we want, we use the [blockname]/[end] bracket pair. Every block pair must therefore end up with an [end] . Note, even inside one wide block there are sub-blocks, each (sub)block itself always has to end up with an [end] . Otherwise, the input file will complain to you about mistakes! For one minimal input file, you need: [mesh] ... [end] and also the Specified Degrees of Freedom ( DoFs ) name or name list that will be displayed in the Paraview when you open the result file (vtu file). Furthermore, when you want to apply the boundary condition, the name of related DoFs is required. [dofs] ... [end] and the element or module you'd like to use: [elmts] ... [end] as well as the necessary information for the analysis(we call it the [job] block) [job] ... [end] To sum up, you at least need: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [job] ... [end] However, one can also use the --read-only option to force AsFem to only read the input file but ignore the FEM analysis workflow. The list of all the blocks in full is: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [mates] ... [end] [bcs] ... [end] [ics] ... [end] [projection] ... [end] [timestepping] ... [end] [nonlinearsolver] ... [end] [qpoint] ... [end] [job] ... [end] In the following steps, we will introduce you the details of each block and their functions. All the input file can be found in the examples/tutorial folder.","title":"Step-0"},{"location":"Tutorial/step-0/#write-a-simple-input-file","text":"In your input file, the layout of the block should look like: [block_name] type=... option1=... option2=... [end] here, to set the properties we want, we use the [blockname]/[end] bracket pair. Every block pair must therefore end up with an [end] . Note, even inside one wide block there are sub-blocks, each (sub)block itself always has to end up with an [end] . Otherwise, the input file will complain to you about mistakes! For one minimal input file, you need: [mesh] ... [end] and also the Specified Degrees of Freedom ( DoFs ) name or name list that will be displayed in the Paraview when you open the result file (vtu file). Furthermore, when you want to apply the boundary condition, the name of related DoFs is required. [dofs] ... [end] and the element or module you'd like to use: [elmts] ... [end] as well as the necessary information for the analysis(we call it the [job] block) [job] ... [end] To sum up, you at least need: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [job] ... [end] However, one can also use the --read-only option to force AsFem to only read the input file but ignore the FEM analysis workflow. The list of all the blocks in full is: [mesh] ... [end] [dofs] ... [end] [elmts] ... [end] [mates] ... [end] [bcs] ... [end] [ics] ... [end] [projection] ... [end] [timestepping] ... [end] [nonlinearsolver] ... [end] [qpoint] ... [end] [job] ... [end] In the following steps, we will introduce you the details of each block and their functions. All the input file can be found in the examples/tutorial folder.","title":"Write a simple input file:"},{"location":"Tutorial/step-1/","text":"Introduction Before we begin the actual FEM simulation, we must define our computation domain and discretize it into multiple subdomains. For this purpose, the [mesh] block is introduced. 1D example Let's take the 1D solid line as an example, this line can be discretized into several 1D Lagrange mesh as follows: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 [end] Options The type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu . Complete mesh block Then the complete [mesh] block should look like: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end] 2D and 3D examples Similarly, for 2D and 3D cases, one can use: [mesh] type=asfem dim=2 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 nx=10 ny=10 meshtype=quad4 [end] and [mesh] type=asfem dim=3 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 zmin=0.0 zmax=1.0 nx=10 ny=10 nz=10 meshtype=hex8 [end] Or, one can also use: [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 [end] then the unit [0,1]x[0,1]x[0,1] 3D domain will be used by default. First try in your AsFem Now, lets try your first example in AsFem. You can create a new text file or simply run the following commands(you can use whatever your like, here we use nano and vim): nano firstrun.i or vim firstrun.i then copy and paste the following [mesh] block into your firstrun.i : [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 savemesh=true [end] save it and then execute your AsFem as follows: asfem -i firstrun.i --read-only or in parallel: mpirun -np 4 asfem -i firstrun.i --read-only Here one need the --read-only option, since we do not have a complete input file but only the [mesh] block. If everthing works fine, you should see the following output: ***************************************************************************** *** Welcome to use AsFem *** *** A Simple Finite Element Method Program *** *** Version: 0.40 Release @ 2021-01-01 *** *** PETSc version: 3.14.3 *** *** License: GPL-3.0 *** *** Author: Yang Bai *** *** Contact: walkandthinker@gmail.com *** *** QQ Group: 879908352 *** *** Website: https://github.com/yangbai90/AsFem *** *** Feel free to use and discuss .:. *** ***************************************************************************** *** Start to create mesh ... *** *** Mesh generation finished ! *** *** Save mesh to [ step1_mesh.vtu] *** ***-----------------------------------------------------------------------*** ***-----------------------------------------------------------------------*** *** Read-only mode analysis is finished ! *** ***************************************************************************** Then, one can use the Paraview to check our 3D mesh, which looks like below: As an exercise for the'[mesh]' block, it is highly recommended to try various options to generate the mesh you need before moving to the next step. The complete input files can be fund in examples/tutorial .","title":"Step-1"},{"location":"Tutorial/step-1/#introduction","text":"Before we begin the actual FEM simulation, we must define our computation domain and discretize it into multiple subdomains. For this purpose, the [mesh] block is introduced.","title":"Introduction"},{"location":"Tutorial/step-1/#1d-example","text":"Let's take the 1D solid line as an example, this line can be discretized into several 1D Lagrange mesh as follows: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 [end]","title":"1D example"},{"location":"Tutorial/step-1/#options","text":"The type= option specifies the type of mesh generation we plan to use. We are offering two kinds of mesh generation in AsFem. The first one is the built-in mesh generation for a regular domain, i.e. the straight line (1d), the rectangle domain (2d), and the cubic domain (3d). For the second one, users can import their favorite mesh from other packages, like gmsh ( type=gmsh ) or netgen ( type=gmsh2 ). dim= determines the domain's dimension, which should be 1, 2, or 3. xmin= and xmax= denote the size of the domain, you will need ymin= and ymax= for the 2D case, and zmin= and zmax= in the 3D case. One can also ignore these options, by default, the size of the domain will be unit, namely [1] in 1D, [1,1] in 2D, [1,1,1] in 3D. Simultaneously, nx , ny , and nz represent the number of mesh along these three axes, respectively. meshtype= option offers the choices of different kinds of mesh, for instance, the second order Lagrange mesh in 1D case can be obtained via meshtype=edge3 . Currently, AsFem offers: edge2,edge3,edge4 // in 1D case quad4,quad8,quad9 // in 2D case hex8, hex20,hex27 // in 3D case If one want to save the created mesh, one will need the savemesh=true option. The mesh will be saved as a .vtu file, which should be named as 'your_input_file_name'+'_mesh.vtu' ( .i is removed from your input file name). For example, if your input file is: test.i , then the mesh file name is: test_mesh.vtu .","title":"Options"},{"location":"Tutorial/step-1/#complete-mesh-block","text":"Then the complete [mesh] block should look like: [mesh] type=asfem dim=1 xmin=0.0 xmax=1.0 nx=10 meshtype=edge2 savemesh=true [end]","title":"Complete mesh block"},{"location":"Tutorial/step-1/#2d-and-3d-examples","text":"Similarly, for 2D and 3D cases, one can use: [mesh] type=asfem dim=2 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 nx=10 ny=10 meshtype=quad4 [end] and [mesh] type=asfem dim=3 xmin=0.0 xmax=1.0 ymin=0.0 ymax=1.0 zmin=0.0 zmax=1.0 nx=10 ny=10 nz=10 meshtype=hex8 [end] Or, one can also use: [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 [end] then the unit [0,1]x[0,1]x[0,1] 3D domain will be used by default.","title":"2D and 3D examples"},{"location":"Tutorial/step-1/#first-try-in-your-asfem","text":"Now, lets try your first example in AsFem. You can create a new text file or simply run the following commands(you can use whatever your like, here we use nano and vim): nano firstrun.i or vim firstrun.i then copy and paste the following [mesh] block into your firstrun.i : [mesh] type=asfem dim=3 nx=10 ny=10 nz=10 meshtype=hex8 savemesh=true [end] save it and then execute your AsFem as follows: asfem -i firstrun.i --read-only or in parallel: mpirun -np 4 asfem -i firstrun.i --read-only Here one need the --read-only option, since we do not have a complete input file but only the [mesh] block. If everthing works fine, you should see the following output: ***************************************************************************** *** Welcome to use AsFem *** *** A Simple Finite Element Method Program *** *** Version: 0.40 Release @ 2021-01-01 *** *** PETSc version: 3.14.3 *** *** License: GPL-3.0 *** *** Author: Yang Bai *** *** Contact: walkandthinker@gmail.com *** *** QQ Group: 879908352 *** *** Website: https://github.com/yangbai90/AsFem *** *** Feel free to use and discuss .:. *** ***************************************************************************** *** Start to create mesh ... *** *** Mesh generation finished ! *** *** Save mesh to [ step1_mesh.vtu] *** ***-----------------------------------------------------------------------*** ***-----------------------------------------------------------------------*** *** Read-only mode analysis is finished ! *** ***************************************************************************** Then, one can use the Paraview to check our 3D mesh, which looks like below: As an exercise for the'[mesh]' block, it is highly recommended to try various options to generate the mesh you need before moving to the next step. The complete input files can be fund in examples/tutorial .","title":"First try in your AsFem"},{"location":"Tutorial/step-2/","text":"Introduction In step-1 , our mesh was defined. Some necessary information, however, is still missing for a simple FEM analysis. Therefore, we will try to define our degrees of freedom (DoFs) in this step and also the element of our model. In the end, to obtain the final solution, we will apply the related boundary conditions. The poisson equation The issue we want to solve is the Poisson linear equation that reads as follows: $$ \\begin{equation} k\\nabla^{2}\\phi=F \\label{eq:poisson} \\tag{1} \\end{equation} $$ where \\(k\\) and \\(F\\) denote the model's coefficients. Below are the related boundary conditions: $$ \\begin{equation} k\\nabla\\phi\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:neumann} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\phi=\\phi_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where the Dirichlet boundary condition and Neumann boundary condition are defined by the subscripts \\(D\\) and \\(N\\) . Define the degree of freedom (DoF) The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end] Options The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else. For the Poisson equation, because there is only one DoF involved, the final expression of [dofs] should be: [dofs] name=phi [end] Element for Poisson equation The DoF is ready now, but the model in Eq. \\(\\eqref{eq:poisson}\\) is still missing. Thereby, we introduce the [elmts] block for this purpose. This block looks like below: [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] where type= option specifies the element we want to use, it could be either the built-in elements of AsFem or the user-defined-element ( UEL ). The DoFs that will be used in this element are defined by dofs= . mate= gives the name of the material block that we want to use. Once the [elmts] block is given, the model we defined in Eq. \\(\\eqref{eq:poisson}\\) is ready. Material properties For the coefficients \\(k\\) and \\(F\\) , namely the material properties, they can be calculated or defined via the [mates] block as follows: [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] where type= specifies the material type name defined in AsFem. params= defines the parameters we want to use in our model, in this case, \\(k=1.0\\) and \\(F=10.0\\) will be used. Boundary conditions The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:dirichlet}\\) and \\(\\eqref{eq:neumann}\\) , can be applied via the [bcs] block. In our case, the Neumann boundary condition in Eq. \\(\\eqref{eq:neumann}\\) is zero, therefore, only the Dirichlet boundary condition need to be considered: [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] where type= specifies the different types of boundary conditions supported by AsFem. dof= denotes the name of DoF we want to apply the given boundary conditions. In our case, we constrain the value of \\(\\phi\\) on the left and right side of a rectangle domain to be 0.1 and 0.5, respectively. Static analysis Until now, all the model and boundary conditions are ready. To start the FEM calculation, we need a [job] block to tell AsFem which kind of analysis we want. For the static analysis in this case, it can be given as follows: [job] type=static [end] if one wants to see how the iteration information changes, one can use: [job] type=static debug=dep [end] where debug= option enables some basic information output in your terminal. If you don't want to see too many outputs, then you can use debug=false . Run it in AsFem Now, let's try your second example in AsFem. You can create a new text file and name it as step2.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=phi [end] [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] [job] type=static [end] You can also find the complete input file in examples/tutorial . If everything goes well, you can see the following image in your Paraview : Wait a minute, what should I do if I want to solve a Poisson equation in 3D? The answer is ...... quite simple, just change your mesh to 3D like this(the complete input file is step2-3d.i ): [mesh] type=asfem dim=3 nx=50 ny=50 nz=50 [end] then you will see:","title":"Step-2"},{"location":"Tutorial/step-2/#introduction","text":"In step-1 , our mesh was defined. Some necessary information, however, is still missing for a simple FEM analysis. Therefore, we will try to define our degrees of freedom (DoFs) in this step and also the element of our model. In the end, to obtain the final solution, we will apply the related boundary conditions.","title":"Introduction"},{"location":"Tutorial/step-2/#the-poisson-equation","text":"The issue we want to solve is the Poisson linear equation that reads as follows: $$ \\begin{equation} k\\nabla^{2}\\phi=F \\label{eq:poisson} \\tag{1} \\end{equation} $$ where \\(k\\) and \\(F\\) denote the model's coefficients. Below are the related boundary conditions: $$ \\begin{equation} k\\nabla\\phi\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:neumann} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\phi=\\phi_{g}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where the Dirichlet boundary condition and Neumann boundary condition are defined by the subscripts \\(D\\) and \\(N\\) .","title":"The poisson equation"},{"location":"Tutorial/step-2/#define-the-degree-of-freedom-dof","text":"The degree of freedom (DoF) or the degrees of freedom (DoFs) can be used to define the name of each DoF and also to apply the necessary boundary conditions ( [bcs] ), elements ( [elmts] ), and so on. The [dofs] block looks like below: [dofs] name=dof1 dof2 dof3 ... [end]","title":"Define the degree of freedom (DoF)"},{"location":"Tutorial/step-2/#options","text":"The name= option specifies the name of each DoF. One should keep in mind that, the order of the name indicates the index of each DoFs. For instance, we need two displacements, namely disp_x and disp_y , if we want to do a 2D elastic analysis. The block of [dofs] should therefore be specified as: [dofs] name=disp_x disp_y [end] where disp_x is the first DoF(index=1), disp_y is the second DoF(index=2). That's all, name= is the only option in [dofs] block, nothing else. For the Poisson equation, because there is only one DoF involved, the final expression of [dofs] should be: [dofs] name=phi [end]","title":"Options"},{"location":"Tutorial/step-2/#element-for-poisson-equation","text":"The DoF is ready now, but the model in Eq. \\(\\eqref{eq:poisson}\\) is still missing. Thereby, we introduce the [elmts] block for this purpose. This block looks like below: [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] where type= option specifies the element we want to use, it could be either the built-in elements of AsFem or the user-defined-element ( UEL ). The DoFs that will be used in this element are defined by dofs= . mate= gives the name of the material block that we want to use. Once the [elmts] block is given, the model we defined in Eq. \\(\\eqref{eq:poisson}\\) is ready.","title":"Element for Poisson equation"},{"location":"Tutorial/step-2/#material-properties","text":"For the coefficients \\(k\\) and \\(F\\) , namely the material properties, they can be calculated or defined via the [mates] block as follows: [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] where type= specifies the material type name defined in AsFem. params= defines the parameters we want to use in our model, in this case, \\(k=1.0\\) and \\(F=10.0\\) will be used.","title":"Material properties"},{"location":"Tutorial/step-2/#boundary-conditions","text":"The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:dirichlet}\\) and \\(\\eqref{eq:neumann}\\) , can be applied via the [bcs] block. In our case, the Neumann boundary condition in Eq. \\(\\eqref{eq:neumann}\\) is zero, therefore, only the Dirichlet boundary condition need to be considered: [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] where type= specifies the different types of boundary conditions supported by AsFem. dof= denotes the name of DoF we want to apply the given boundary conditions. In our case, we constrain the value of \\(\\phi\\) on the left and right side of a rectangle domain to be 0.1 and 0.5, respectively.","title":"Boundary conditions"},{"location":"Tutorial/step-2/#static-analysis","text":"Until now, all the model and boundary conditions are ready. To start the FEM calculation, we need a [job] block to tell AsFem which kind of analysis we want. For the static analysis in this case, it can be given as follows: [job] type=static [end] if one wants to see how the iteration information changes, one can use: [job] type=static debug=dep [end] where debug= option enables some basic information output in your terminal. If you don't want to see too many outputs, then you can use debug=false .","title":"Static analysis"},{"location":"Tutorial/step-2/#run-it-in-asfem","text":"Now, let's try your second example in AsFem. You can create a new text file and name it as step2.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=phi [end] [elmts] [elmt1] type=poisson dofs=phi mate=mymate [end] [end] [mates] [mymate] type=constpoisson params=1.0 1.0e1 [end] [end] [bcs] [fixleft] type=dirichlet dof=phi value=0.1 boundary=left [end] [fixright] type=dirichlet dof=phi value=0.5 boundary=right [end] [end] [job] type=static [end] You can also find the complete input file in examples/tutorial . If everything goes well, you can see the following image in your Paraview : Wait a minute, what should I do if I want to solve a Poisson equation in 3D? The answer is ...... quite simple, just change your mesh to 3D like this(the complete input file is step2-3d.i ): [mesh] type=asfem dim=3 nx=50 ny=50 nz=50 [end] then you will see:","title":"Run it in AsFem"},{"location":"Tutorial/step-3/","text":"Introduction In this step, we will try to solve the linear elasticity problem. The stress equilibrium equation The problem we want to solve is the equation of stress equilibrium that reads as follows: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-eq} \\tag{1} \\end{equation} $$ where \\(\\mathbf{\\sigma}\\) denotes Cauchy stress tensor. The constitutive laws for the stress and strain of the small deformation case are below: $$ \\begin{equation} \\mathbf{\\sigma}=\\mathbb{C}:\\mathbf{\\epsilon} \\label{eq:stress} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{\\epsilon}=\\frac{1}{2}(\\nabla\\mathbf{u}+\\nabla \\mathbf{u}^{T}) \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where \\(\\mathbf{u}\\) is the displacement vector. \\(\\mathbb{C}\\) represents the elasticity tensor, which is a function of the Youngs modulus \\(E\\) and Poisson ratio \\(\\nu\\) . The related boundary conditions can be read as: $$ \\begin{equation} \\mathbf{t}\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:traction} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{u}=\\mathbf{u}_{0}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:disp} \\tag{5} \\end{equation} $$ where the traction free condition is assumed in Eq. \\(\\eqref{eq:traction}\\) Define a mesh For our calculation, we use a rectangular domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] where a \\(50\\times50\\) mesh is defined. Define the DoFs The DoFs used in this step is the displacement vector, namely \\(u_{x}\\) and \\(u_{y}\\) . Then the [dofs] block can be read as: [dofs] name=ux uy [end] Element for stress equilibrium equation The model in Eq. \\(\\eqref{eq:stress-eq}\\) can be applied in the following lines [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] where type=mechanics option specifies the element we want to use for solid mechanics problem. Moreover, we will use the linear elasticity material property, therefore, the related material definition will be given in mymate block. Linear elasticity material Via the following lines in your [mates] block, the linear elasticity material can be easily defined: [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] where type=linearelastic specifies linear elasticity material type. params= defines the Youngs modulus ( \\(E=210GPa\\) ) and Poisson ratio ( \\(\\nu=0.3\\) ) Boundary conditions The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:disp}\\) , can be applied via the [bcs] block. In our case, the traction boundary condition in Eq. \\(\\eqref{eq:traction}\\) is zero, therefore, only the displacement boundary condition needs to be considered: [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] where we fix the \\(u_{x}\\) and \\(u_{y}\\) to be zero at the bottom edge. While \\(u_{y}=0.1\\) is applied at the top edge of the domain. Static analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=static debug=dep [end] Projection Wait for a minute, where are the stresses and strain? How can I output them? Noooo worries, the [projection] block can help you to project the quantities on each Gauss point to the Nodal point of your mesh. So, if we want to check how the vonMises stress, \\(\\sigma_{xx}\\) , \\(\\sigma_{yy}\\) , \\(\\sigma_{xy}\\) looks like, we can use: [projection] name=vonMises stress_xx stress_yy stress_xy [end] Done! Explanation of projection There is no magic for [projection] block, if you take a look at our MechanicsElmt.cpp in the ElmtSystem class, you will find the following code: gpProj[0]=ScalarMaterials.at(\"vonMises\"); gpProj[1]=Rank2Materials.at(\"stress\")(1,1);//sigma_xx if(nDim==2){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[4]=Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[5]=Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[6]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } else if(nDim==3){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(3,3);//sigma_zz gpProj[4]=Rank2Materials.at(\"stress\")(2,3);//sigma_yz gpProj[5]=Rank2Materials.at(\"stress\")(1,3);//sigma_xz gpProj[6]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[7] =Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[8] =Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[9] =Rank2Materials.at(\"strain\")(3,3);//epsilon_zz gpProj[10]=Rank2Materials.at(\"strain\")(2,3);//epsilon_yz gpProj[11]=Rank2Materials.at(\"strain\")(1,3);//epsilon_xz gpProj[12]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } Yelp, the order of the name you give in your [projection] block is related to the gpProj quantities in your element. So, if you want to project the quantities in a 3D case, then you will need: [projection] name=vonMises stress_xx stress_yy stress_zz stress_yz stress_xz stress_xy [end] Hold on, where is my strain tensor in 2D case? Take it easy, here it is: [projection] name=vonMises stress_xx stress_yy stress_xy epsilon_xx epsilon_yy epsilon_xy [end] Done! Run it in AsFem Now, let's try your third example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=ux uy [end] [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] [projection] name=vonMises stress_xx stress_yy stress_xy [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step3.i . If everything goes well, you can see the following image in your Paraview :","title":"Step-3"},{"location":"Tutorial/step-3/#introduction","text":"In this step, we will try to solve the linear elasticity problem.","title":"Introduction"},{"location":"Tutorial/step-3/#the-stress-equilibrium-equation","text":"The problem we want to solve is the equation of stress equilibrium that reads as follows: $$ \\begin{equation} \\mathbf{\\nabla}\\cdot\\mathbf{\\sigma}=\\mathbf{0} \\label{eq:stress-eq} \\tag{1} \\end{equation} $$ where \\(\\mathbf{\\sigma}\\) denotes Cauchy stress tensor. The constitutive laws for the stress and strain of the small deformation case are below: $$ \\begin{equation} \\mathbf{\\sigma}=\\mathbb{C}:\\mathbf{\\epsilon} \\label{eq:stress} \\tag{2} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{\\epsilon}=\\frac{1}{2}(\\nabla\\mathbf{u}+\\nabla \\mathbf{u}^{T}) \\label{eq:dirichlet} \\tag{3} \\end{equation} $$ where \\(\\mathbf{u}\\) is the displacement vector. \\(\\mathbb{C}\\) represents the elasticity tensor, which is a function of the Youngs modulus \\(E\\) and Poisson ratio \\(\\nu\\) . The related boundary conditions can be read as: $$ \\begin{equation} \\mathbf{t}\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:traction} \\tag{4} \\end{equation} $$ and $$ \\begin{equation} \\mathbf{u}=\\mathbf{u}_{0}\\qquad\\mathrm{on}\\quad\\partial\\Omega_{D} \\label{eq:disp} \\tag{5} \\end{equation} $$ where the traction free condition is assumed in Eq. \\(\\eqref{eq:traction}\\)","title":"The stress equilibrium equation"},{"location":"Tutorial/step-3/#define-a-mesh","text":"For our calculation, we use a rectangular domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] where a \\(50\\times50\\) mesh is defined.","title":"Define a mesh"},{"location":"Tutorial/step-3/#define-the-dofs","text":"The DoFs used in this step is the displacement vector, namely \\(u_{x}\\) and \\(u_{y}\\) . Then the [dofs] block can be read as: [dofs] name=ux uy [end]","title":"Define the DoFs"},{"location":"Tutorial/step-3/#element-for-stress-equilibrium-equation","text":"The model in Eq. \\(\\eqref{eq:stress-eq}\\) can be applied in the following lines [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] where type=mechanics option specifies the element we want to use for solid mechanics problem. Moreover, we will use the linear elasticity material property, therefore, the related material definition will be given in mymate block.","title":"Element for stress equilibrium equation"},{"location":"Tutorial/step-3/#linear-elasticity-material","text":"Via the following lines in your [mates] block, the linear elasticity material can be easily defined: [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] where type=linearelastic specifies linear elasticity material type. params= defines the Youngs modulus ( \\(E=210GPa\\) ) and Poisson ratio ( \\(\\nu=0.3\\) )","title":"Linear elasticity material"},{"location":"Tutorial/step-3/#boundary-conditions","text":"The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:disp}\\) , can be applied via the [bcs] block. In our case, the traction boundary condition in Eq. \\(\\eqref{eq:traction}\\) is zero, therefore, only the displacement boundary condition needs to be considered: [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] where we fix the \\(u_{x}\\) and \\(u_{y}\\) to be zero at the bottom edge. While \\(u_{y}=0.1\\) is applied at the top edge of the domain.","title":"Boundary conditions"},{"location":"Tutorial/step-3/#static-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=static debug=dep [end]","title":"Static analysis"},{"location":"Tutorial/step-3/#projection","text":"Wait for a minute, where are the stresses and strain? How can I output them? Noooo worries, the [projection] block can help you to project the quantities on each Gauss point to the Nodal point of your mesh. So, if we want to check how the vonMises stress, \\(\\sigma_{xx}\\) , \\(\\sigma_{yy}\\) , \\(\\sigma_{xy}\\) looks like, we can use: [projection] name=vonMises stress_xx stress_yy stress_xy [end] Done!","title":"Projection"},{"location":"Tutorial/step-3/#explanation-of-projection","text":"There is no magic for [projection] block, if you take a look at our MechanicsElmt.cpp in the ElmtSystem class, you will find the following code: gpProj[0]=ScalarMaterials.at(\"vonMises\"); gpProj[1]=Rank2Materials.at(\"stress\")(1,1);//sigma_xx if(nDim==2){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[4]=Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[5]=Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[6]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } else if(nDim==3){ gpProj[2]=Rank2Materials.at(\"stress\")(2,2);//sigma_yy gpProj[3]=Rank2Materials.at(\"stress\")(3,3);//sigma_zz gpProj[4]=Rank2Materials.at(\"stress\")(2,3);//sigma_yz gpProj[5]=Rank2Materials.at(\"stress\")(1,3);//sigma_xz gpProj[6]=Rank2Materials.at(\"stress\")(1,2);//sigma_xy gpProj[7] =Rank2Materials.at(\"strain\")(1,1);//epsilon_xx gpProj[8] =Rank2Materials.at(\"strain\")(2,2);//epsilon_yy gpProj[9] =Rank2Materials.at(\"strain\")(3,3);//epsilon_zz gpProj[10]=Rank2Materials.at(\"strain\")(2,3);//epsilon_yz gpProj[11]=Rank2Materials.at(\"strain\")(1,3);//epsilon_xz gpProj[12]=Rank2Materials.at(\"strain\")(1,2);//epsilon_xy } Yelp, the order of the name you give in your [projection] block is related to the gpProj quantities in your element. So, if you want to project the quantities in a 3D case, then you will need: [projection] name=vonMises stress_xx stress_yy stress_zz stress_yz stress_xz stress_xy [end] Hold on, where is my strain tensor in 2D case? Take it easy, here it is: [projection] name=vonMises stress_xx stress_yy stress_xy epsilon_xx epsilon_yy epsilon_xy [end] Done!","title":"Explanation of projection"},{"location":"Tutorial/step-3/#run-it-in-asfem","text":"Now, let's try your third example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=5.0 ymax=5.0 nx=50 ny=50 meshtype=quad4 [end] [dofs] name=ux uy [end] [elmts] [mysolid] type=mechanics dofs=ux uy mate=mymate [end] [end] [mates] [mymate] type=linearelastic params=210.0 0.3 [end] [end] [bcs] [fixbottomX] type=dirichlet dof=ux value=0.0 boundary=bottom [end] [fixbottomY] type=dirichlet dof=uy value=0.0 boundary=bottom [end] [loadY] type=dirichlet dof=uy value=0.1 boundary=top [end] [end] [projection] name=vonMises stress_xx stress_yy stress_xy [end] [job] type=static debug=dep [end] You can also find the complete input file in examples/tutorial/step3.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-4/","text":"Introduction In this step, we will try to solve the linear diffusion problem. The diffusion equation The problem we want to solve is the diffusion equation that reads as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(D\\nabla c) \\label{eq:diffusion-eq} \\tag{1} \\end{equation} $$ where \\(c\\) denotes the concentration of the species. \\(D\\) is the diffusion coefficient The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=-0.5\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{2} \\end{equation} $$ where the flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) . Define the mesh For our calculation, we use a cubic domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] where a \\(1\\times1\\times10\\) mesh is defined. Define the DoFs The DoFs used in this step is the concentration, namely \\(c\\) . Then the [dofs] block can be read as: [dofs] name=c [end] Element for the diffusion equation The model in Eq. \\(\\eqref{eq:diffusion-eq}\\) can be applied in the following lines [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] where type=diffusion option specifies the element we want to use for the diffusion problem. Moreover, we will use the constant diffusivity material property, therefore, the related material definition will be given in mymate block. Constant diffusivity material property Via the following lines in your [mates] block, the constant diffusivity \\(D\\) can be easily defined: [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] where type=constdiffusion specifies constant diffusivity material type. params= defines the diffusivity \\(D\\) ( \\(D=10.0\\) ). Boundary conditions The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:flux}\\) , can be applied via the [bcs] block. In our case, only the flux boundary ( Neumann ) condition needs to be considered: [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] where we apply a constant flux to the front surface of our cubic domain. Transient analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end] Timestepping Wait for a minute, where are the settings for the transient analysis, for instance the initial \\(\\Delta_t\\) and the final time? Noooo worries, the [timestepping] block can help you to set the different time stepping method as well as the \\(\\Delta_t\\) , \\(T_{\\mathrm{final}}\\) stuffs. The layout of this block looks like below: [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. It should be mentioned that, AsFem only support the implicit method, the explicit method like Forward-Euler (fe) is not supported! dt=1.0e-3 defines that the initial \\(\\Delta_{t}\\) is \\(10^{-3}\\) , while time=1.0e0 means the final time is 1.0. Done! Run it in AsFem Now, let's try your fourth example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] [dofs] name=c [end] [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step4.i . If everything goes well, you can see the following image in your Paraview : The outputs You may see the following outputs from your terminal: ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4306e-02,|dU|= 3.0700e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3957e-15,|dU|= 2.4301e-03,dt=1.00e-03 *** *** Time step= 999, time= 9.99000e-01, dt= 1.00000e-03 *** *** Write result to step4-00000999.vtu *** ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4303e-02,|dU|= 3.0723e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3530e-15,|dU|= 2.4296e-03,dt=1.00e-03 *** *** Time step= 1000, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-00001000.vtu *** ***-----------------------------------------------------------------------*** *** Time step= -1, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-000000-1.vtu *** ***-----------------------------------------------------------------------*** One can see that, when the current time \\(t\\) reaches \\(1.0\\) , the related output file name is step4-00001000.vtu (for the 1000-th step). Moreover, AsFem will also give the final output step4-000000-1.vtu , which could be very helpful when \\(t_{\\mathrm{old}}+\\Delta_{t}>T_{\\mathrm{final}}\\) .","title":"Step-4"},{"location":"Tutorial/step-4/#introduction","text":"In this step, we will try to solve the linear diffusion problem.","title":"Introduction"},{"location":"Tutorial/step-4/#the-diffusion-equation","text":"The problem we want to solve is the diffusion equation that reads as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(D\\nabla c) \\label{eq:diffusion-eq} \\tag{1} \\end{equation} $$ where \\(c\\) denotes the concentration of the species. \\(D\\) is the diffusion coefficient The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=-0.5\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{2} \\end{equation} $$ where the flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) .","title":"The diffusion equation"},{"location":"Tutorial/step-4/#define-the-mesh","text":"For our calculation, we use a cubic domain here, and then the [mesh] block can be given as: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] where a \\(1\\times1\\times10\\) mesh is defined.","title":"Define the mesh"},{"location":"Tutorial/step-4/#define-the-dofs","text":"The DoFs used in this step is the concentration, namely \\(c\\) . Then the [dofs] block can be read as: [dofs] name=c [end]","title":"Define the DoFs"},{"location":"Tutorial/step-4/#element-for-the-diffusion-equation","text":"The model in Eq. \\(\\eqref{eq:diffusion-eq}\\) can be applied in the following lines [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] where type=diffusion option specifies the element we want to use for the diffusion problem. Moreover, we will use the constant diffusivity material property, therefore, the related material definition will be given in mymate block.","title":"Element for the diffusion equation"},{"location":"Tutorial/step-4/#constant-diffusivity-material-property","text":"Via the following lines in your [mates] block, the constant diffusivity \\(D\\) can be easily defined: [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] where type=constdiffusion specifies constant diffusivity material type. params= defines the diffusivity \\(D\\) ( \\(D=10.0\\) ).","title":"Constant diffusivity material property"},{"location":"Tutorial/step-4/#boundary-conditions","text":"The boundary conditions, as mentioned in Eq. \\(\\eqref{eq:flux}\\) , can be applied via the [bcs] block. In our case, only the flux boundary ( Neumann ) condition needs to be considered: [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] where we apply a constant flux to the front surface of our cubic domain.","title":"Boundary conditions"},{"location":"Tutorial/step-4/#transient-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end]","title":"Transient analysis"},{"location":"Tutorial/step-4/#timestepping","text":"Wait for a minute, where are the settings for the transient analysis, for instance the initial \\(\\Delta_t\\) and the final time? Noooo worries, the [timestepping] block can help you to set the different time stepping method as well as the \\(\\Delta_t\\) , \\(T_{\\mathrm{final}}\\) stuffs. The layout of this block looks like below: [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. It should be mentioned that, AsFem only support the implicit method, the explicit method like Forward-Euler (fe) is not supported! dt=1.0e-3 defines that the initial \\(\\Delta_{t}\\) is \\(10^{-3}\\) , while time=1.0e0 means the final time is 1.0. Done!","title":"Timestepping"},{"location":"Tutorial/step-4/#run-it-in-asfem","text":"Now, let's try your fourth example in AsFem. You can create a new text file and name it as step3.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=3 xmax=1.0 ymax=1.0 zmax=10.0 nx=5 ny=5 nz=50 meshtype=hex8 [end] [dofs] name=c [end] [elmts] [mydiffusion] type=diffusion dofs=c mate=mymate [end] [end] [mates] [mymate] type=constdiffusion params=1.0e1 [end] [end] [bcs] [flux] type=neumann dof=c value=-0.5 boundary=front [end] [end] [timestepping] type=be dt=1.0e-3 time=1.0e0 [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step4.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"},{"location":"Tutorial/step-4/#the-outputs","text":"You may see the following outputs from your terminal: ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4306e-02,|dU|= 3.0700e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3957e-15,|dU|= 2.4301e-03,dt=1.00e-03 *** *** Time step= 999, time= 9.99000e-01, dt= 1.00000e-03 *** *** Write result to step4-00000999.vtu *** ***-----------------------------------------------------------------------*** *** SNES solver:iters= 0,|R|= 1.4303e-02,|dU|= 3.0723e+00,dt=1.00e-03 *** *** SNES solver:iters= 1,|R|= 1.3530e-15,|dU|= 2.4296e-03,dt=1.00e-03 *** *** Time step= 1000, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-00001000.vtu *** ***-----------------------------------------------------------------------*** *** Time step= -1, time= 1.00000e+00, dt= 1.00000e-03 *** *** Write result to step4-000000-1.vtu *** ***-----------------------------------------------------------------------*** One can see that, when the current time \\(t\\) reaches \\(1.0\\) , the related output file name is step4-00001000.vtu (for the 1000-th step). Moreover, AsFem will also give the final output step4-000000-1.vtu , which could be very helpful when \\(t_{\\mathrm{old}}+\\Delta_{t}>T_{\\mathrm{final}}\\) .","title":"The outputs"},{"location":"Tutorial/step-5/","text":"Introduction In this step, we will try to solve the CahnHilliard equation for the spinodal decomposition problem. The CahnHilliard equation The CahnHilliard equation can be read as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(M(c)\\nabla\\mu) \\label{eq:ch-c} \\tag{1} \\end{equation} $$ and $$ \\begin{equation} \\mu=\\frac{\\delta f}{\\delta c} \\label{eq:ch-mu} \\tag{2} \\end{equation} $$ where \\(c\\) and \\(\\mu\\) denote the concentration and chemical potential, respectively. \\(M(c)\\) is the concentration dependent mobility, in this model we use \\(M(c)=Dc(1-c)\\) , where \\(D\\) is the diffusion coefficient. Free energy In this model, we use the following free energy: $$ \\begin{equation} f=c\\ln(c)+(1-c)\\ln(1-c)+\\chi c(1-c)+\\kappa|\\nabla c|^{2} \\label{eq:free-energy} \\tag{3} \\end{equation} $$ thereby, the chemical potential \\(\\mu\\) can be expressed as: $$ \\begin{equation} \\mu=\\ln(c)-\\ln(1-c)+\\chi(1-c)-\\kappa\\nabla^{2}c \\label{eq:mu} \\tag{4} \\end{equation} $$ where \\(\\chi\\) denotes the interaction between two phases. \\(\\kappa\\) represents the interface energy contribution, which is proportional to the thickness of the phase interface. The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{5} \\end{equation} $$ where the zero flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) . Define the mesh We use a square domain here for our calculation, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] where a \\(4\\times4\\) mesh is defined. Gauss point integration (optional) If one wants to use second order mesh, for instance meshtype=quad9 , then one need to use a higher order gauss points. This can be implemented via: [qpoint] type=gauss order=3 [end] Normally, you don't need this block! Define the DoFs In order to solve the 4th order equation, we split the CH equation into two second-order equations. Therefore, the DoFs used in this step are the concentration \\(c\\) and the chemical potential \\(\\mu\\) . Then the [dofs] block can be read as: [dofs] name=c mu [end] Element for the CahnHilliard equation The model in Eq. \\(\\eqref{eq:ch-c}\\) and \\(\\eqref{eq:ch-mu}\\) can be applied in the following lines [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] where type=cahnhilliard option specifies the element we want to use for the CahnHilliard equation. Moreover, we will use the free energy ( \\(F\\) ), the first order derivative of free energy( \\(\\frac{\\partial F}{\\partial c}\\) ), and the second order derivative of free energy( \\(\\frac{\\partial^{2}f}{\\partial c^{2}}\\) ) material properties. Therefore, the related material definition will be given in myf block. free energy material Via the following lines in your [mates] block, the material properties, i.e. \\(F\\) , \\(\\frac{\\partial F}{\\partial c}\\) , and \\(\\frac{\\partial^{2}F}{\\partial c^{2}}\\) can be easily defined: [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 [end] [end] where type=cahnhilliard specifies constant diffusivity material type. Don't worry, here we used the same name as the type= in [elmts] block. But AsFem knows that they belong to two different blocks, so it's fine. params= defines the diffusivity \\(D=1.0\\) , the phase interaction constant \\(\\chi=2.5\\) , and the interface parameter \\(\\kappa=0.02\\) . If you are using a coarse mesh, please increase \\(\\kappa\\) to a larger value, i.e. 0.02 or even higher. Boundary conditions Since the zero flux boundary condition is applied, we don't need any [bcs] block. If Eq. \\(\\eqref{eq:flux}\\) is nonzero, then you will definitely need the [bcs] block. Transient analysis Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end] Timestepping In this case, we will use the adaptive time stepping to speed up our simulation. The layout of our [timestepping] block looks like below: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. dt=1.0e-5 defines that the initial \\(\\Delta_{t}\\) and time=1.0e3 means the final time is 1000.0. adaptive=true enables the adaptive time stepping. optiters=3 indicates that if the nonlinear iterations is not greater than 3, then AsFem will increase the new delta t to be \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{growth}}\\) . Otherwise, the new delta t will be reduced as \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{cut}}\\) . growthfactor and cutfactor represent \\(\\alpha_{\\mathrm{growth}}\\) and \\(\\alpha_{\\mathrm{cut}}\\) , respectively. Initial condition Now, in order to allow the phase separation to take place, we must add the random value to the concentration. As follows, the random concentration value can be applied through the'[ics]' block: [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] where the random value is applied via the type=random option. dof= indicates which DoF will be used. params= represent the parameters used in the initial condition calculation. For the type=random case, 0.6 and 0.66 are the min and max value of the random numbers. Parallel solver In order to further speed up our simulation, we involve the parallel solver from either mumps or superlu_dist . This can be defined via the [nonlinearsolver] block: [nonlinearsolver] type=nr solver=superlu [end] where type=nr indicates the newton-raphson method. solver= determines the name of the parallel solver, in this case, the superlu_dist solver is used. It should be noted that, if external solvers, i.e. mumps and superlu , are not compiled within your PETSc, then you can only use the built-in solver. In short, this option doesn\u2019t make sense to you. Run it in AsFem Now, let's try your fourth example in AsFem. You can create a new text file and name it as step5.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] [dofs] name=c mu [end] [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 // D Chi Kappa [end] [end] [timestepping] type=be dt=1.0e-5 time=3.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] [nonlinearsolver] type=nr solver=superlu [end] [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step5.i . If everything goes well, you can see the following image in your Paraview :","title":"Step-5"},{"location":"Tutorial/step-5/#introduction","text":"In this step, we will try to solve the CahnHilliard equation for the spinodal decomposition problem.","title":"Introduction"},{"location":"Tutorial/step-5/#the-cahnhilliard-equation","text":"The CahnHilliard equation can be read as follows: $$ \\begin{equation} \\frac{\\partial c}{\\partial t}=\\nabla\\cdot(M(c)\\nabla\\mu) \\label{eq:ch-c} \\tag{1} \\end{equation} $$ and $$ \\begin{equation} \\mu=\\frac{\\delta f}{\\delta c} \\label{eq:ch-mu} \\tag{2} \\end{equation} $$ where \\(c\\) and \\(\\mu\\) denote the concentration and chemical potential, respectively. \\(M(c)\\) is the concentration dependent mobility, in this model we use \\(M(c)=Dc(1-c)\\) , where \\(D\\) is the diffusion coefficient.","title":"The CahnHilliard equation"},{"location":"Tutorial/step-5/#free-energy","text":"In this model, we use the following free energy: $$ \\begin{equation} f=c\\ln(c)+(1-c)\\ln(1-c)+\\chi c(1-c)+\\kappa|\\nabla c|^{2} \\label{eq:free-energy} \\tag{3} \\end{equation} $$ thereby, the chemical potential \\(\\mu\\) can be expressed as: $$ \\begin{equation} \\mu=\\ln(c)-\\ln(1-c)+\\chi(1-c)-\\kappa\\nabla^{2}c \\label{eq:mu} \\tag{4} \\end{equation} $$ where \\(\\chi\\) denotes the interaction between two phases. \\(\\kappa\\) represents the interface energy contribution, which is proportional to the thickness of the phase interface. The related boundary conditions can be read as: $$ \\begin{equation} -D\\nabla c\\cdot\\vec{n}=0\\qquad\\mathrm{on}\\quad\\partial\\Omega_{N} \\label{eq:flux} \\tag{5} \\end{equation} $$ where the zero flux ( Neumann ) boundary condition is assumed in Eq. \\(\\eqref{eq:flux}\\) .","title":"Free energy"},{"location":"Tutorial/step-5/#define-the-mesh","text":"We use a square domain here for our calculation, and then the [mesh] block can be given as: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] where a \\(4\\times4\\) mesh is defined.","title":"Define the mesh"},{"location":"Tutorial/step-5/#gauss-point-integration-optional","text":"If one wants to use second order mesh, for instance meshtype=quad9 , then one need to use a higher order gauss points. This can be implemented via: [qpoint] type=gauss order=3 [end] Normally, you don't need this block!","title":"Gauss point integration (optional)"},{"location":"Tutorial/step-5/#define-the-dofs","text":"In order to solve the 4th order equation, we split the CH equation into two second-order equations. Therefore, the DoFs used in this step are the concentration \\(c\\) and the chemical potential \\(\\mu\\) . Then the [dofs] block can be read as: [dofs] name=c mu [end]","title":"Define the DoFs"},{"location":"Tutorial/step-5/#element-for-the-cahnhilliard-equation","text":"The model in Eq. \\(\\eqref{eq:ch-c}\\) and \\(\\eqref{eq:ch-mu}\\) can be applied in the following lines [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] where type=cahnhilliard option specifies the element we want to use for the CahnHilliard equation. Moreover, we will use the free energy ( \\(F\\) ), the first order derivative of free energy( \\(\\frac{\\partial F}{\\partial c}\\) ), and the second order derivative of free energy( \\(\\frac{\\partial^{2}f}{\\partial c^{2}}\\) ) material properties. Therefore, the related material definition will be given in myf block.","title":"Element for the CahnHilliard equation"},{"location":"Tutorial/step-5/#free-energy-material","text":"Via the following lines in your [mates] block, the material properties, i.e. \\(F\\) , \\(\\frac{\\partial F}{\\partial c}\\) , and \\(\\frac{\\partial^{2}F}{\\partial c^{2}}\\) can be easily defined: [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 [end] [end] where type=cahnhilliard specifies constant diffusivity material type. Don't worry, here we used the same name as the type= in [elmts] block. But AsFem knows that they belong to two different blocks, so it's fine. params= defines the diffusivity \\(D=1.0\\) , the phase interaction constant \\(\\chi=2.5\\) , and the interface parameter \\(\\kappa=0.02\\) . If you are using a coarse mesh, please increase \\(\\kappa\\) to a larger value, i.e. 0.02 or even higher.","title":"free energy material"},{"location":"Tutorial/step-5/#boundary-conditions","text":"Since the zero flux boundary condition is applied, we don't need any [bcs] block. If Eq. \\(\\eqref{eq:flux}\\) is nonzero, then you will definitely need the [bcs] block.","title":"Boundary conditions"},{"location":"Tutorial/step-5/#transient-analysis","text":"Again, we need a [job] block to start the FEM calculation, which can be given as follows: [job] type=transient debug=dep [end]","title":"Transient analysis"},{"location":"Tutorial/step-5/#timestepping","text":"In this case, we will use the adaptive time stepping to speed up our simulation. The layout of our [timestepping] block looks like below: [timestepping] type=be dt=1.0e-5 time=1.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] where type=be specifies the Backward-Euler (be) method for implicit time integration. dt=1.0e-5 defines that the initial \\(\\Delta_{t}\\) and time=1.0e3 means the final time is 1000.0. adaptive=true enables the adaptive time stepping. optiters=3 indicates that if the nonlinear iterations is not greater than 3, then AsFem will increase the new delta t to be \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{growth}}\\) . Otherwise, the new delta t will be reduced as \\(\\Delta_{t}=\\Delta_{t,\\mathrm{old}}*\\alpha_{\\mathrm{cut}}\\) . growthfactor and cutfactor represent \\(\\alpha_{\\mathrm{growth}}\\) and \\(\\alpha_{\\mathrm{cut}}\\) , respectively.","title":"Timestepping"},{"location":"Tutorial/step-5/#initial-condition","text":"Now, in order to allow the phase separation to take place, we must add the random value to the concentration. As follows, the random concentration value can be applied through the'[ics]' block: [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] where the random value is applied via the type=random option. dof= indicates which DoF will be used. params= represent the parameters used in the initial condition calculation. For the type=random case, 0.6 and 0.66 are the min and max value of the random numbers.","title":"Initial condition"},{"location":"Tutorial/step-5/#parallel-solver","text":"In order to further speed up our simulation, we involve the parallel solver from either mumps or superlu_dist . This can be defined via the [nonlinearsolver] block: [nonlinearsolver] type=nr solver=superlu [end] where type=nr indicates the newton-raphson method. solver= determines the name of the parallel solver, in this case, the superlu_dist solver is used. It should be noted that, if external solvers, i.e. mumps and superlu , are not compiled within your PETSc, then you can only use the built-in solver. In short, this option doesn\u2019t make sense to you.","title":"Parallel solver"},{"location":"Tutorial/step-5/#run-it-in-asfem","text":"Now, let's try your fourth example in AsFem. You can create a new text file and name it as step5.i or whatever you like. Then copy the following lines into your input file: [mesh] type=asfem dim=2 xmax=4.0 ymax=4.0 nx=100 ny=100 meshtype=quad4 [end] [dofs] name=c mu [end] [elmts] [mych] type=cahnhilliard dofs=c mu mate=myf [end] [end] [mates] [myf] type=cahnhilliard params=1.0 2.5 0.005 // D Chi Kappa [end] [end] [timestepping] type=be dt=1.0e-5 time=3.0e3 adaptive=true optiters=3 growthfactor=1.1 cutfactor=0.85 [end] [nonlinearsolver] type=nr solver=superlu [end] [ics] [ic1] type=random dof=c params=0.6 0.66 [end] [end] [job] type=transient debug=dep [end] You can also find the complete input file in examples/tutorial/step5.i . If everything goes well, you can see the following image in your Paraview :","title":"Run it in AsFem"}]}